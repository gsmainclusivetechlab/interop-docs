---
title: Overview
sidebar_label: Overview
---

This section describes the high-level architecture of the Interoperability Test
Platform. The platform was designed to be scalable and integrate with novel
systems in future, and so it was designed around a flexible architecture
consisting of three sections:

- Core Test Platform
- Simulators
- Systems Under Test (SUTs)

![High Level Architecture](/img/architecture_high_level.png)

## Core Test Platform

The core test platform presents a frontend interface to manage users, sessions
and test cases. In addition, it presents a proxy layer which is capable of
intercepting and validating every message between simulators and SUTs. The
platform uses [Laravel](https://laravel.com/), a web application framework built
with PHP.

### Frontend

The frontend is responsible for rendering the user interface and uses two main
technologies: [Vue.js](https://vuejs.org/) and [Tabler](https://tabler.io/).

- Vue.js: Used to build a single page application, rendered through
  [Inertia.js](https://inertiajs.com/).
- Tabler: Provides the admin and dashboard layout to build the UI, using
  [Bootstrap](https://getbootstrap.com/) internally.

### Test Manager

The core of the test platform is the test manager. Test cases define the
execution flow of tests, as well as defining schema validation and business rule
validations. Schema validation is performed automatically bsed on an OpenAPI
Specification (powered by
[OpenAPI PSR-7 Message Validator](https://github.com/thephpleague/openapi-psr7-validator)),
while business rule validations are controlled by custom logic defined inside
the test case definition.

### Proxy

In order to provide an end-to-end test, the platform must be able to follow all
messages exchanged between entities. All messages within the system pass through
a proxy layer, allowing the platform to store and validate messages before
forwarding them to the correct recipient. When the receiver sends an HTTP
response, that too will be validated before forwarding back to the original
sender.

This diagram illustrates communication through the proxy layer. More details
about these connections are available [here](/architecture/connections).

import { DelayedGraphviz } from "../../src/components/DelayedGraphviz";

<DelayedGraphviz
  timeout={1000}
  options={{ width: "100%", height: "auto" }}
  dot={`
    digraph {
      node [ fontname="var(--ifm-font-family)", shape="box", margin=0.3, penwidth=2];
      edge [ fontname="var(--ifm-font-family)", penwidth=2];
      rankdir="TD"
      ratio="fill";
      size="3,1";
      simulator1 [ label="Simulator 1"]
      sut [ label="System \nUnder Test"]
      simulator2 [ label="Simulator 2"]
      simulatorN [ label="Simulator N"]
      ITP [ label="Test Platform"]
      subgraph sim {
        rank="same"
        simulator1 -> sut -> simulator2 -> simulatorN -> simulator2 -> sut -> simulator1[ style="dashed"]
      }
      ITP -> {simulator1 sut simulator2 simulatorN} [dir="both"]
      subgraph cluster_key {
        style=invis;
        {
          node [ width=0.5, height=0.3, label="", style="invis" ];
          rank = same;
          edge[ minlen = 2 ];
          leg1 -> leg2[ label="Actual Message" ];
          leg2 -> leg4[ style = dashed, label="Logical Message"];
        }
      }
      sut -> leg2 [style=invis] ;
      simulator2 -> leg2 [style=invis] ;
    }
`}
/>

## Simulators

Every component in the system may be either a simulated component, or a real
component known as a SUT. The behaviour of simulated components is entirely
defined within the test case file. Within the file, a series of test steps is
defined, with each step including a sample `request` and `response`. By playing
back these requests and responses in sequence, a full system flow can be
simulated.

## System Under Test

Any of the simulated requests and responses can be replaced by a real message
generated by a live system. This live system is known as a "System Under Test"
(SUT). When creating a test session, any component can be selected to be a SUT
for the duration of this session. Once it is selected, it replaces the simulator
representing that component for the duration of the test, and becomes
responsible for generating all requests and responses from that component.
